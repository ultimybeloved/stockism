rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user owns this document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is admin
    function isAdmin() {
      return isAuthenticated() && request.auth.uid == '4usiVxPmHLhmitEKH2HfCpbx4Yi1';
    }
    
    // Get the user's current data
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Check if a field is being modified
    function fieldChanged(field) {
      return request.resource.data[field] != resource.data[field];
    }
    
    // ============================================
    // USERNAMES COLLECTION (case-insensitive uniqueness)
    // ============================================

    match /usernames/{username} {
      // Anyone can read (for availability checking)
      allow read: if true;

      // Only Cloud Functions can write (via admin SDK)
      // This ensures atomic username reservation
      allow write: if false;
    }

    // ============================================
    // USER DOCUMENTS
    // ============================================

    match /users/{userId} {
      // Anyone can read user data (for public leaderboard)
      allow read: if true;

      // User creation is now handled by Cloud Functions
      // This ensures atomic username uniqueness checking
      // Direct creation is disabled - use createUser Cloud Function
      allow create: if false;

      // Updates - owner can update their own document, admin can update any
      allow update: if isAdmin() || (isOwner(userId) && validateUserUpdate());

      // Admin can delete user documents (for cleanup)
      allow delete: if isAdmin();
    }
    
    // Validate user document updates to prevent cheating
    function validateUserUpdate() {
      let oldData = resource.data;
      let newData = request.resource.data;

      return (
        // Cannot set positive cash if bankrupt (must use bailout)
        (newData.cash >= 0 || oldData.cash < 0) &&
        
        // Cannot fake total checkins (can only increment by 1)
        (!('totalCheckins' in newData) || 
         !('totalCheckins' in oldData) ||
         newData.totalCheckins <= oldData.totalCheckins + 1) &&
        
        // Cannot fake total trades (can only increment by 1)  
        (!('totalTrades' in newData) ||
         !('totalTrades' in oldData) ||
         newData.totalTrades <= oldData.totalTrades + 1) &&
        
        // Cannot grant yourself lending access
        (!('lendingUnlocked' in newData) ||
         newData.lendingUnlocked == oldData.lendingUnlocked ||
         // Only allow if legitimately earned (server should verify)
         oldData.lendingUnlocked == false) &&
        
        // Cannot un-bankrupt yourself
        (!('isBankrupt' in newData) ||
         newData.isBankrupt == oldData.isBankrupt ||
         newData.isBankrupt == true) && // Can only become bankrupt, not recover
        
        // Display name cannot be changed (prevents impersonation)
        (newData.displayName == oldData.displayName)
      );
    }
    
    // ============================================
    // MARKET DATA
    // ============================================
    
    match /market/{document} {
      // Everyone can read market data
      allow read: if true;

      // Market writes - admin can do anything, regular users have restrictions
      allow update: if isAdmin() || (isAuthenticated() && validateMarketUpdate());

      // Only admin can create market documents
      // Use merge-safe create (setDoc with merge:true still needs create permission)
      allow create: if isAdmin() || (isAuthenticated() && validateMarketCreate());

      // Price history archive sub-collection
      match /price_history/{ticker} {
        allow read: if true;
        allow write: if isAuthenticated();
      }
    }

    // Validate market creation (for merge:true setDoc calls)
    function validateMarketCreate() {
      let newData = request.resource.data;

      return (
        // Must have prices object
        ('prices' in newData) &&
        newData.prices != null &&
        // Must have priceHistory object
        ('priceHistory' in newData) &&
        newData.priceHistory != null
      );
    }

    function validateMarketUpdate() {
      let oldData = resource.data;
      let newData = request.resource.data;

      // Price changes must be reasonable (max 20% per update)
      // This prevents someone setting a price to $0.01 or $999999

      // Check if any price changed by more than 20%
      // Note: This is a simplified check - full validation would check each ticker

      return (
        // Total trades can only increment
        (!('totalTrades' in newData) ||
         !('totalTrades' in oldData) ||
         newData.totalTrades >= oldData.totalTrades) &&

        // Prices must stay within reasonable bounds
        // Min price: $0.01, Max price: $10,000
        validatePriceBounds(newData.prices) &&

        // CRITICAL: Prevent complete priceHistory replacement
        // Only allow field-level updates (adding new entries), not wholesale replacement
        validatePriceHistoryUpdate(oldData, newData)
      );
    }

    function validatePriceBounds(prices) {
      // This is a simplified check
      // Full validation would iterate through all prices
      // For now, we trust that most prices are valid if the structure exists
      return prices != null;
    }

    // Prevent wholesale price history deletion/replacement
    function validatePriceHistoryUpdate(oldData, newData) {
      // If priceHistory exists in old data, it must exist in new data
      // (prevents accidental deletion)
      let hadHistory = 'priceHistory' in oldData && oldData.priceHistory != null;
      let hasHistory = 'priceHistory' in newData && newData.priceHistory != null;

      // If old document had history, new one must preserve it
      // Admin can bypass this by direct Firestore console edits
      return !hadHistory || hasHistory;
    }
    
    // ============================================
    // PREDICTIONS
    // ============================================
    
    match /predictions/{document} {
      // Everyone can read predictions
      allow read: if true;
      
      // Only admin can create/delete predictions
      allow create, delete: if isAdmin();
      
      // Updates allowed for:
      // - Admin (can do anything)
      // - Regular users (can only add bets)
      allow update: if isAdmin() || validatePredictionBet();
    }
    
    function validatePredictionBet() {
      // Users can update the list field to add bet amounts to pools
      // The list structure contains prediction objects with pools
      let oldData = resource.data;
      let newData = request.resource.data;

      return (
        isAuthenticated() &&
        // Must have a list field (array of predictions)
        'list' in newData &&
        // List must exist in both old and new
        'list' in oldData &&
        // List sizes must match (can't add/remove predictions)
        newData.list.size() == oldData.list.size()
        // Note: Full validation would check that only pool amounts increased
        // and user has sufficient cash. Cloud Functions recommended for this.
      );
    }
    
    // ============================================
    // PRICE HISTORY (if stored separately)
    // ============================================
    
    match /priceHistory/{document} {
      allow read: if true;
      allow write: if isAuthenticated(); // Allow for now, lock down with Cloud Functions later
    }
    
    // ============================================
    // ADMIN-ONLY COLLECTIONS
    // ============================================
    
    match /admin/{document} {
      allow read, write: if isAdmin();
    }
    
    match /config/{document} {
      allow read: if true;
      allow write: if isAdmin();
    }
  }
}
