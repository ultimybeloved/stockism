rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user owns this document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is admin
    // Note: Admin UID should be set via Firebase environment config in production
    function isAdmin() {
      return isAuthenticated() && request.auth.uid == '4usiVxPmHLhmitEKH2HfCpbx4Yi1';
    }

    // List of public fields that can be read by anyone (for leaderboard)
    function isPublicUserField(field) {
      return field in ['displayName', 'displayNameLower', 'portfolioValue', 'peakPortfolioValue',
                       'totalTrades', 'totalCheckins', 'achievements', 'pins', 'badges',
                       'crew', 'crewIcon', 'crewRole', 'isBot', 'isBanned', 'createdAt',
                       'predictionWins', 'predictionStreak', 'lendingUnlocked'];
    }

    // ============================================
    // USERNAMES COLLECTION (case-insensitive uniqueness)
    // ============================================

    match /usernames/{username} {
      // Anyone can read (for availability checking)
      allow read: if true;

      // Only Cloud Functions can write (via admin SDK)
      // This ensures atomic username reservation
      allow write: if false;
    }

    // ============================================
    // USER DOCUMENTS
    // ============================================

    match /users/{userId} {
      // Read access:
      // - Owner can read all their own data
      // - Admin can read all user data
      // - Others can only read for leaderboard queries (portfolioValue ordering)
      // Note: Firestore doesn't support field-level read rules, so we allow read
      // but sensitive operations should use Cloud Functions for data filtering
      allow read: if isOwner(userId) || isAdmin() || true;
      // TODO: For true field-level security, move leaderboard to a separate
      // /leaderboard collection with only public data, populated by Cloud Functions

      // User creation is now handled by Cloud Functions
      // This ensures atomic username uniqueness checking
      // Direct creation is disabled - use createUser Cloud Function
      allow create: if false;

      // Updates - owner can update their own document, admin can update any
      allow update: if isAdmin() || isOwner(userId);

      // Admin can delete user documents (for cleanup)
      allow delete: if isAdmin();
    }
    
    // ============================================
    // MARKET DATA
    // ============================================
    
    match /market/{document} {
      // Everyone can read market data
      allow read: if true;

      // Market writes - admin can do anything, regular users have restrictions
      allow update: if isAdmin() || (isAuthenticated() && validateMarketUpdate());

      // Only admin can create market documents
      // Use merge-safe create (setDoc with merge:true still needs create permission)
      allow create: if isAdmin() || (isAuthenticated() && validateMarketCreate());

      // Price history archive sub-collection
      match /price_history/{ticker} {
        allow read: if true;
        allow write: if isAuthenticated();
      }
    }

    // Validate market creation (for merge:true setDoc calls)
    function validateMarketCreate() {
      let newData = request.resource.data;

      return (
        // Must have prices object
        ('prices' in newData) &&
        newData.prices != null &&
        // Must have priceHistory object
        ('priceHistory' in newData) &&
        newData.priceHistory != null
      );
    }

    function validateMarketUpdate() {
      let oldData = resource.data;
      let newData = request.resource.data;

      // Price changes must be reasonable (max 20% per update)
      // This prevents someone setting a price to $0.01 or $999999

      // Check if any price changed by more than 20%
      // Note: This is a simplified check - full validation would check each ticker

      return (
        // Total trades can only increment
        (!('totalTrades' in newData) ||
         !('totalTrades' in oldData) ||
         newData.totalTrades >= oldData.totalTrades) &&

        // Prices must stay within reasonable bounds
        // Min price: $0.01, Max price: $10,000
        validatePriceBounds(newData.prices) &&

        // CRITICAL: Prevent complete priceHistory replacement
        // Only allow field-level updates (adding new entries), not wholesale replacement
        validatePriceHistoryUpdate(oldData, newData)
      );
    }

    function validatePriceBounds(prices) {
      // This is a simplified check
      // Full validation would iterate through all prices
      // For now, we trust that most prices are valid if the structure exists
      return prices != null;
    }

    // Prevent wholesale price history deletion/replacement
    function validatePriceHistoryUpdate(oldData, newData) {
      // If priceHistory exists in old data, it must exist in new data
      // (prevents accidental deletion)
      let hadHistory = 'priceHistory' in oldData && oldData.priceHistory != null;
      let hasHistory = 'priceHistory' in newData && newData.priceHistory != null;

      // If old document had history, new one must preserve it
      // Admin can bypass this by direct Firestore console edits
      return !hadHistory || hasHistory;
    }
    
    // ============================================
    // PREDICTIONS
    // ============================================
    
    match /predictions/{document} {
      // Everyone can read predictions
      allow read: if true;
      
      // Only admin can create/delete predictions
      allow create, delete: if isAdmin();
      
      // Updates allowed for:
      // - Admin (can do anything)
      // - Regular users (can only add bets)
      allow update: if isAdmin() || validatePredictionBet();
    }
    
    function validatePredictionBet() {
      // Users can update the list field to add bet amounts to pools
      // The list structure contains prediction objects with pools
      let oldData = resource.data;
      let newData = request.resource.data;

      return (
        isAuthenticated() &&
        // Must have a list field (array of predictions)
        'list' in newData &&
        // List must exist in both old and new
        'list' in oldData &&
        // List sizes must match (can't add/remove predictions)
        newData.list.size() == oldData.list.size()
        // Note: Full validation would check that only pool amounts increased
        // and user has sufficient cash. Cloud Functions recommended for this.
      );
    }
    
    // ============================================
    // PRICE HISTORY (if stored separately)
    // ============================================
    
    match /priceHistory/{document} {
      allow read: if true;
      allow write: if isAuthenticated(); // Allow for now, lock down with Cloud Functions later
    }
    
    // ============================================
    // LADDER GAME COLLECTIONS
    // ============================================

    // Global ladder game data (history, stats)
    match /ladderGame/{document} {
      // Everyone can read global history
      allow read: if true;

      // Only Cloud Functions can write (server-side game logic)
      allow write: if false;
    }

    // Individual ladder game user data
    match /ladderGameUsers/{userId} {
      // Everyone can read (for leaderboard)
      allow read: if true;

      // Only Cloud Functions can write (server-side balance updates)
      allow write: if false;
    }

    // ============================================
    // LIMIT ORDERS
    // ============================================

    match /limitOrders/{orderId} {
      // Users can read their own orders, admins can read all
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || isAdmin());

      // Users can create orders for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       validateLimitOrder();

      // Users can update/cancel their own orders, admins can update any
      allow update: if isAuthenticated() &&
                       (resource.data.userId == request.auth.uid || isAdmin());

      // Only admins can delete orders
      allow delete: if isAdmin();
    }

    function validateLimitOrder() {
      let data = request.resource.data;
      return (
        // Required fields exist
        'userId' in data &&
        'ticker' in data &&
        'type' in data &&
        'shares' in data &&
        'limitPrice' in data &&
        'status' in data &&
        'createdAt' in data &&

        // Field types are correct
        data.shares is int &&
        data.shares > 0 &&
        data.limitPrice is number &&
        data.limitPrice > 0 &&
        data.type in ['BUY', 'SELL', 'SHORT', 'COVER'] &&
        data.status == 'PENDING'
      );
    }

    // ============================================
    // TRADES COLLECTION (audit log)
    // ============================================

    match /trades/{tradeId} {
      // Admin can read all trades
      // Users can read their own trades (for trade history)
      allow read: if isAdmin() || (isAuthenticated() && resource.data.uid == request.auth.uid);

      // Only Cloud Functions can write (server-side trade logging)
      allow write: if false;
    }

    // ============================================
    // ADMIN-ONLY COLLECTIONS
    // ============================================

    match /admin/{document} {
      allow read, write: if isAdmin();
    }

    match /config/{document} {
      allow read: if true;
      allow write: if isAdmin();
    }
  }
}
